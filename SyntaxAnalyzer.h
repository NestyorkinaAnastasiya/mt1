#pragma once
#include "lexicalAnalyzer.h"
#include <stack>
using namespace l_analyzer;

namespace s_analyzer
{ 
	struct LL_1
	{
		//множество терминальных направляющих символов 
		//либо сам символ
		//пустая строка - множество символов следования 
		//для исходного нетерминала
		vector<string> terms;
		//номер состояния:
		//НТС в лч- первого состояния правой части этого правила
		//НТС в пч - где этот нетерминал не последний в лч правила
		//(если есть альт правила - то номер первого из них)
		//ТС номер следующего состояния за данным в пч правила, 
		//если Т последний, то 0
		//пустая строка - 0
		int jump;
		//всегда "истина" при ТС
		//в остальных случаях - всегда "ложь"
		bool accept;
		//всегда "ложь", кроме НС в пч
		//заполняем «истина», если этот нетерминал 
		//не последний символ в правой части правила, иначе «ложь»;
		bool stack;
		//пустая строка - всегда истина
		//ТС - «истина», если этот терминал последний в правой 
		//части правила, иначе «ложь»;
		//остальное всегда "ложь"
		bool ret;
		//всегда "истина", кроме НТС в лч:
		//«error» – «истина», если правило для нетерминала единственное, 
		//либо это последнее из альтернативных правил. Для всех альтернативных 
		//правил, кроме последнего – «ложь».
		bool error;
		int Search(string str);
	};

	struct err
	{
		int line;
		string text;
		void Set(Token n_l, string tx) { line = n_l.line; text = tx; };
	};

	class SyntaxAnalyzer
	{	// Лексический анализатор
		LexicalAnalyzer LA;
		// Таблица разбора грамматики LL(1)
		vector<LL_1> table;
		// Стек состояний
		stack<int> stackPositions;
		// Стек корректных состояний
		stack<int> correctStates;
		// Последнее корректное состояние
		int correctPosition;
		// Номер текущего токена
		int numberOfToken;

		// Вектор ошибок
		vector <err> errors;
		// Постфиксные записи
		vector <vector<Token>> RPnotations;

		// Текущая позиция
		int curPosition = 0;
		// Предыдущая позиция
		int prevPosition;
		// Ошибка
		bool error = false;
		// Конец анализа
		bool theEnd = false;
		// Текст ошибки
		string errText = "";

		// Получение приоритета операции
		int GetPriority(string operation);
		// Получение строкового значения токена
		string GetValue(Token tk);
		// Создание элемента обратной польской записи
		void MakePolsk(stack<Token>& st_p, vector<Token>& res, Token tk, bool & error);
		// Завершение польской записи
		void EndPolsk(stack<Token>& st_p, vector<Token>& res, bool & error);
		// Завершение текущего процесса до ;
		void ToTheEndOfSentence();
		// Анализ при помощи таблицы разбора
		void WorkWithTable(string strToken);
		// Печать строкового значения токена
		void PrintToken(ofstream &file, Token tok);
		// Вывод результатов
		void Output();
	public:
		// Запуск синтаксического анализа
		void Analyze();
		SyntaxAnalyzer();
	};

}

/*По строке текущего состояния:

1) Если обрабатываемый символ входной цепочки встречается в столбце «terminals» , то переход на шаг 3, иначе на шаг 2.

2) Если в столбце «error» стоит «истина», то сообщить об обнаруженной ошибке «Неожиданный символ», Конец разбора. Иначе перейти в следующее по номеру состояние и переход на шаг 1.

3) Если в столбце «accept» стоит «истина», то считать из входной строки следующий символ.

4) Если в столбце «stack» стоит «истина», то поместить в стек состояний номер следующего состояния.

5) Если в столбце «jump» стоит положительное число (номер состояния), то перейти в состояние с этим номером и переход на шаг 1.

6) Если в столбце «return» стоит «истина», то взять номер состояния из стека, перейти в это состояние и переход на шаг 1.*/
